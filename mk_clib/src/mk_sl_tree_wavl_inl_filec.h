#include "mk_lang_assert.h"
#include "mk_lang_attribute.h"
#include "mk_lang_check.h"
#include "mk_lang_clobber.h"
#include "mk_lang_constexpr.h"
#include "mk_lang_inline.h"
#include "mk_lang_jumbo.h"
#include "mk_lang_limits.h"
#include "mk_lang_nodiscard.h"
#include "mk_lang_noexcept.h"
#include "mk_lang_static_assert.h"
#include "mk_lang_types.h"


#include "mk_sl_tree_wavl_inl_defd.h"


mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_elements_compare_fn(mk_sl_tree_wavl_inl_defd_element_pct const a, mk_sl_tree_wavl_inl_defd_element_pct const b, mk_lang_types_sint_pt const lt) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_elements_compare(a, b, lt); }

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_init(mk_lang_types_void_t) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_init(); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_deinit(mk_lang_types_void_t) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_deinit(); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_allocate(mk_lang_types_usize_t const size, mk_lang_types_void_ppt const mem) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_allocate(size, mem); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_deallocate(mk_lang_types_void_pct const mem, mk_lang_types_usize_t const size) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_deallocate(mem, size); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_reallocate(mk_lang_types_void_pct const old_mem, mk_lang_types_usize_t const old_size, mk_lang_types_usize_t const new_size, mk_lang_types_void_ppt const new_mem) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_reallocate(old_mem, old_size, new_size, new_mem); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_statistics_get_bytes_allocated(mk_sl_cui_uint128_pt const cnt) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_statistics_get_bytes_allocated(cnt); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_statistics_get_bytes_deallocated(mk_sl_cui_uint128_pt const cnt) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_statistics_get_bytes_deallocated(cnt); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_statistics_get_bytes_live(mk_sl_cui_uint128_pt const cnt) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_statistics_get_bytes_live(cnt); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_statistics_get_bytes_peak(mk_sl_cui_uint128_pt const cnt) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_statistics_get_bytes_peak(cnt); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_statistics_get_blocks_allocated(mk_sl_cui_uint128_pt const cnt) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_statistics_get_blocks_allocated(cnt); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_statistics_get_blocks_deallocated(mk_sl_cui_uint128_pt const cnt) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_statistics_get_blocks_deallocated(cnt); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_statistics_get_blocks_live(mk_sl_cui_uint128_pt const cnt) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_statistics_get_blocks_live(cnt); }
mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_mallocatorg_statistics_get_blocks_peak(mk_sl_cui_uint128_pt const cnt) mk_lang_noexcept { return mk_sl_tree_wavl_inl_defd_base_mallocatorg_statistics_get_blocks_peak(cnt); }


struct mk_sl_tree_wavl_inl_defd_node_s
{
	mk_sl_tree_wavl_inl_defd_node_pt m_left;
	mk_sl_tree_wavl_inl_defd_node_pt m_right;
	mk_sl_tree_wavl_inl_defd_node_pt m_parent;
	mk_lang_types_sint_t m_ref_count_and_rank_diff;
	mk_sl_tree_wavl_inl_defd_element_t m_element;
};


mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_is_root(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const is_root) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_bool_t ret mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(is_root);

	ret = !node->m_parent;
	*is_root = ret;
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_is_binary(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const is_binary) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_bool_t ret mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(is_binary);

	ret = node->m_left && node->m_right;
	*is_binary = ret;
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_is_unary(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const is_unary) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_bool_t ret mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(is_unary);

	ret = (node->m_left && !node->m_right) || (!node->m_left && node->m_right);
	*is_unary = ret;
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_is_leaf(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const is_leaf) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_bool_t ret mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(is_leaf);

	ret = !node->m_left && !node->m_right;
	*is_leaf = ret;
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_is_internal(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const is_internal) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t is_leaf mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(is_internal);

	err = mk_sl_tree_wavl_inl_defd_prro_node_is_leaf(node, &is_leaf); mk_lang_check_rereturn(err);
	*is_internal = !is_leaf;
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_is_external(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const is_external) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t is_leaf mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(is_external);

	err = mk_sl_tree_wavl_inl_defd_prro_node_is_leaf(node, &is_leaf); mk_lang_check_rereturn(err);
	*is_external = is_leaf;
	return 0;
}}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_get_next(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_sl_tree_wavl_inl_defd_node_ppct const next) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pct curr mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pct parent mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(next);

	curr = node;
	if(curr->m_left)
	{
		curr = curr->m_left;
	}
	else if(curr->m_right)
	{
		curr = curr->m_right;
	}
	else
	{
		for(;;)
		{
			parent = curr->m_parent;
			if(!parent)
			{
				curr = mk_lang_null;
				break;
			}
			mk_lang_assert(curr == parent->m_left || curr == parent->m_right);
			if(curr == parent->m_left && parent->m_right)
			{
				curr = parent->m_right;
				break;
			}
			else
			{
				curr = parent;
			}
		}
	}
	*next = curr;
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_has_cycle(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const has_cycle) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pct ita mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pct itb mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(has_cycle);

	ita = node;
	itb = node;
	for(;;)
	{
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_next(ita, &ita); mk_lang_check_rereturn(err);
		if(!ita)
		{
			*has_cycle = mk_lang_false;
			break;
		}
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_next(itb, &itb); mk_lang_check_rereturn(err);
		if(!itb)
		{
			*has_cycle = mk_lang_false;
			break;
		}
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_next(itb, &itb); mk_lang_check_rereturn(err);
		if(!itb)
		{
			*has_cycle = mk_lang_false;
			break;
		}
		if(itb == ita)
		{
			*has_cycle = mk_lang_true;
			break;
		}
	}
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_is_cmp(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const is_cmp) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pct it mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t cmp mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(is_cmp);
	mk_lang_assert(*is_cmp);

	it = node;
	while(it)
	{
		if(it->m_left)
		{
			err = mk_sl_tree_wavl_inl_defd_elements_compare_fn(&it->m_left->m_element, &it->m_element, &cmp); mk_lang_check_rereturn(err);
			if(!(cmp < 0))
			{
				*is_cmp = mk_lang_false;
				break;
			}
		}
		if(it->m_right)
		{
			err = mk_sl_tree_wavl_inl_defd_elements_compare_fn(&it->m_right->m_element, &it->m_element, &cmp); mk_lang_check_rereturn(err);
			if(!(cmp > 0))
			{
				*is_cmp = mk_lang_false;
				break;
			}
		}
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_next(it, &it); mk_lang_check_rereturn(err);
	}
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_is_valid(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const is_valid) mk_lang_noexcept
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t has_cycle mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t is_cmp mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(is_valid);
	mk_lang_assert(*is_valid);

	if(node)
	{
		err = mk_sl_tree_wavl_inl_defd_prro_node_has_cycle(node, &has_cycle); mk_lang_check_rereturn(err);
		if(has_cycle)
		{
			*is_valid = mk_lang_false;
		}
		is_cmp = mk_lang_true;
		err = mk_sl_tree_wavl_inl_defd_prro_node_is_cmp(node, &is_cmp); mk_lang_check_rereturn(err);
		if(!is_cmp)
		{
			*is_valid = mk_lang_false;
		}
	}
	return 0;
}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_lang_types_bool_pt const bit) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_bool_t b mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(bit);

	if(!node)
	{
		b = mk_lang_true;
	}
	else
	{
		b = ((mk_lang_types_uint_t)(((mk_lang_types_uint_t)(node->m_ref_count_and_rank_diff)) & ((mk_lang_types_uint_t)(0x1u)))) != ((mk_lang_types_uint_t)(0u));
	}
	*bit = b;
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_get_sibling(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_sl_tree_wavl_inl_defd_node_ppct const sibling) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_sl_tree_wavl_inl_defd_node_pct parent mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(sibling);

	parent = node->m_parent;
	if(parent)
	{
		mk_lang_assert(parent->m_left == node || parent->m_right == node);
		*sibling = parent->m_left == node ? parent->m_right : parent->m_left;
	}
	else
	{
		*sibling = mk_lang_null;
	}
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_node_is_2child(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_sl_tree_wavl_inl_defd_node_pct const parent, mk_lang_types_bool_pt const is_2child) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t ba mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t bb mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(is_2child);

	err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(node, &ba); mk_lang_check_rereturn(err);
	err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(parent, &bb); mk_lang_check_rereturn(err);
	*is_2child = ba == bb;
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_set_rank_bit(mk_sl_tree_wavl_inl_defd_node_pt const node, mk_lang_types_bool_t const bit) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_assert(node);
	mk_lang_assert(bit == mk_lang_true || bit == mk_lang_false);

	node->m_ref_count_and_rank_diff = ((mk_lang_types_sint_t)(((mk_lang_types_uint_t)((((mk_lang_types_uint_t)((mk_lang_types_uint_t)(node->m_ref_count_and_rank_diff)) & ((mk_lang_types_uint_t)(~((mk_lang_types_uint_t)(0x1u)))))) | ((mk_lang_types_uint_t)(bit ? 1u : 0u))))));
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_get_sibling(mk_sl_tree_wavl_inl_defd_node_pt const tree_node, mk_sl_tree_wavl_inl_defd_node_ppt const sibling) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_sl_tree_wavl_inl_defd_node_pct parent mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree_node);
	mk_lang_assert(sibling);

	parent = tree_node->m_parent;
	if(parent)
	{
		mk_lang_assert(parent->m_left == tree_node || parent->m_right == tree_node);
		*sibling = parent->m_left == tree_node ? parent->m_right : parent->m_left;
	}
	else
	{
		*sibling = mk_lang_null;
	}
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_find_minimum(mk_sl_tree_wavl_inl_defd_node_pt const node, mk_sl_tree_wavl_inl_defd_node_ppt const minimum) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_sl_tree_wavl_inl_defd_node_pt curr mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(minimum);

	curr = node;
	while(curr->m_left)
	{
		curr = curr->m_left;
	}
	*minimum = curr;
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_promote_single(mk_sl_tree_wavl_inl_defd_node_pt const node) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t b mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);

	err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(node, &b); mk_lang_check_rereturn(err);
	b = !b;
	err = mk_sl_tree_wavl_inl_defd_prrw_node_set_rank_bit(node, b); mk_lang_check_rereturn(err);
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_promote_double(mk_sl_tree_wavl_inl_defd_node_pt const node) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_assert(node);

	((mk_lang_types_void_t)(node));
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(mk_sl_tree_wavl_inl_defd_node_pt const node) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t b mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);

	err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(node, &b); mk_lang_check_rereturn(err);
	b = !b;
	err = mk_sl_tree_wavl_inl_defd_prrw_node_set_rank_bit(node, b); mk_lang_check_rereturn(err);
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_demote_double(mk_sl_tree_wavl_inl_defd_node_pt const node) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_assert(node);

	((mk_lang_types_void_t)(node));
	return 0;
}}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_alloc(mk_sl_tree_wavl_inl_defd_node_ppt const node, mk_sl_tree_wavl_inl_defd_node_pt const parent, mk_sl_tree_wavl_inl_defd_element_pct const element) mk_lang_noexcept
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt tmp mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(element);

	err = mk_sl_tree_wavl_inl_defd_mallocatorg_allocate(sizeof(*tmp), ((mk_lang_types_void_ppt)(&tmp))); mk_lang_check_rereturn(err); mk_lang_assert(tmp);
	tmp->m_left = mk_lang_null;
	tmp->m_right = mk_lang_null;
	tmp->m_parent = parent;
	tmp->m_ref_count_and_rank_diff = 2;
	tmp->m_element = *element;
	*node = tmp;
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_destroy_single(mk_sl_tree_wavl_inl_defd_node_pt const node) mk_lang_noexcept
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;

	if(node)
	{
		err = mk_sl_tree_wavl_inl_defd_mallocatorg_deallocate(node, sizeof(*node)); mk_lang_check_rereturn(err);
	}
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_destroy_recursive(mk_sl_tree_wavl_inl_defd_node_pt const node) mk_lang_noexcept
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;

	if(node)
	{
		err = mk_sl_tree_wavl_inl_defd_prrw_node_destroy_recursive(node->m_left); mk_lang_check_rereturn(err);
		err = mk_sl_tree_wavl_inl_defd_prrw_node_destroy_recursive(node->m_right); mk_lang_check_rereturn(err);
		err = mk_sl_tree_wavl_inl_defd_prrw_node_destroy_single(node); mk_lang_check_rereturn(err);
	}
	return 0;
}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_inc(mk_sl_tree_wavl_inl_defd_node_pt const node) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_assert(node);
	mk_lang_assert(node->m_ref_count_and_rank_diff <= mk_lang_limits_sint_max - 2);

	node->m_ref_count_and_rank_diff += 2;
	return 0;
}}

mk_lang_nodiscard mk_lang_attribute_msvc_forceinline mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_node_dec(mk_sl_tree_wavl_inl_defd_node_pt const node, mk_lang_types_bool_pt const del) mk_lang_noexcept { mk_lang_attribute_msvc_flatten
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(node);
	mk_lang_assert(node->m_ref_count_and_rank_diff >= 2);
	mk_lang_assert(del);

	node->m_ref_count_and_rank_diff -= 2;
	*del = node->m_ref_count_and_rank_diff <= 1;
	return 0;
}}


mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_validate_impl3(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_sl_tree_wavl_inl_defd_node_pct const child, mk_lang_types_bool_pt const validated) mk_lang_noexcept
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t cmp mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(validated);

	if(node)
	{
		if(node->m_left)
		{
			err = mk_sl_tree_wavl_inl_defd_elements_compare_fn(&node->m_left->m_element, &node->m_element, &cmp); mk_lang_check_rereturn(err);
			if(!(cmp < 0))
			{
				*validated == mk_lang_false;
			}
		}
		if(node->m_right)
		{
			err = mk_sl_tree_wavl_inl_defd_elements_compare_fn(&node->m_right->m_element, &node->m_element, &cmp); mk_lang_check_rereturn(err);
			if(!(cmp > 0))
			{
				*validated == mk_lang_false;
			}
		}
		if(child == node)
		{
			*validated == mk_lang_false;
		}
		if(child)
		{
			err = mk_sl_tree_wavl_inl_defd_prro_validate_impl3(node, child->m_left, validated); mk_lang_check_rereturn(err);
			err = mk_sl_tree_wavl_inl_defd_prro_validate_impl3(node, child->m_right, validated); mk_lang_check_rereturn(err);
		}
	}
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prro_validate_impl(mk_sl_tree_wavl_inl_defd_pct const tree, mk_lang_types_bool_pt const validated) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pct node mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree);
	mk_lang_assert(validated);
	mk_lang_assert(*validated);

	node = tree->m_root;
	err = mk_sl_tree_wavl_inl_defd_prro_node_is_valid(node, validated); mk_lang_check_rereturn(err);
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_bool_t mk_sl_tree_wavl_inl_defd_prro_validate(mk_sl_tree_wavl_inl_defd_pct const tree) mk_lang_noexcept
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t validated mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree);

	validated = mk_lang_true;
	err = mk_sl_tree_wavl_inl_defd_prro_validate_impl(tree, &validated);
	return err == 0 && validated;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_rotate_left_single(mk_sl_tree_wavl_inl_defd_pt const tree_wavl, mk_sl_tree_wavl_inl_defd_node_pt const tree_node) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pt parent mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt sibling mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt grand mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree_wavl);
	mk_lang_assert(tree_node);

	parent = tree_node->m_parent;
	sibling = tree_node->m_left;
	grand = parent->m_parent;
	tree_node->m_parent = grand;
	if(grand)
	{
		if(grand->m_left == parent)
		{
			grand->m_left = tree_node;
		}
		else
		{
			grand->m_right = tree_node;
		}
	}
	else
	{
		tree_wavl->m_root = tree_node;
	}
	tree_node->m_left = parent;
	parent->m_parent = tree_node;
	parent->m_right = sibling;
	if(sibling)
	{
		sibling->m_parent = parent;
	}
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_rotate_right_single(mk_sl_tree_wavl_inl_defd_pt const tree_wavl, mk_sl_tree_wavl_inl_defd_node_pt const tree_node) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pt parent mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt sibling mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt grand mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree_wavl);
	mk_lang_assert(tree_node);

	parent = tree_node->m_parent;
	sibling = tree_node->m_right;
	grand = parent->m_parent;
	tree_node->m_parent = grand;
	if(grand)
	{
		if(grand->m_left == parent)
		{
			grand->m_left = tree_node;
		}
		else
		{
			grand->m_right = tree_node;
		}
	}
	else
	{
		tree_wavl->m_root = tree_node;
	}
	tree_node->m_right = parent;
	parent->m_parent = tree_node;
	parent->m_left = sibling;
	if(sibling)
	{
		sibling->m_parent = parent;
	}
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_rotate_left_double(mk_sl_tree_wavl_inl_defd_pt const tree_wavl, mk_sl_tree_wavl_inl_defd_node_pt const tree_node) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pt parent mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt grand mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt uber mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt sibling mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree_wavl);
	mk_lang_assert(tree_node);
	mk_lang_assert(tree_node->m_parent);
	mk_lang_assert(tree_node->m_parent->m_parent);

	parent = tree_node->m_parent;
	grand = parent->m_parent;
	uber = grand->m_parent;
	tree_node->m_parent = uber;
	if(uber)
	{
		if(uber->m_left == grand)
		{
			uber->m_left = tree_node;
		}
		else
		{
			uber->m_right = tree_node;
		}
	}
	else
	{
		tree_wavl->m_root = tree_node;
	}
	grand->m_right = tree_node->m_left;
	if(tree_node->m_left)
	{
		sibling = tree_node->m_left;
		sibling->m_parent = grand;
	}
	tree_node->m_left = grand;
	grand->m_parent = tree_node;
	parent->m_left = tree_node->m_right;
	if(tree_node->m_right)
	{
		sibling = tree_node->m_right;
		sibling->m_parent = parent;
	}
	tree_node->m_right = parent;
	parent->m_parent = tree_node;
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_rotate_right_double(mk_sl_tree_wavl_inl_defd_pt const tree_wavl, mk_sl_tree_wavl_inl_defd_node_pt const tree_node) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pt parent mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt grand mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt uber mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt sibling mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree_wavl);
	mk_lang_assert(tree_node);
	mk_lang_assert(tree_node->m_parent);
	mk_lang_assert(tree_node->m_parent->m_parent);

	parent = tree_node->m_parent;
	grand = parent->m_parent;
	uber = grand->m_parent;
	tree_node->m_parent = uber;
	if(uber)
	{
		if(uber->m_left == grand)
		{
			uber->m_left = tree_node;
		}
		else
		{
			uber->m_right = tree_node;
		}
	}
	else
	{
		tree_wavl->m_root = tree_node;
	}
	parent->m_right = tree_node->m_left;
	if(tree_node->m_left)
	{
		sibling = tree_node->m_left;
		sibling->m_parent = parent;
	}
	tree_node->m_left = parent;
	parent->m_parent = tree_node;
	grand->m_left = tree_node->m_right;
	if(tree_node->m_right)
	{
		sibling = tree_node->m_right;
		sibling->m_parent = grand;
	}
	tree_node->m_right = grand;
	grand->m_parent = tree_node;
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_rebalance_insert(mk_sl_tree_wavl_inl_defd_pt const tree_wavl, mk_sl_tree_wavl_inl_defd_node_pt const tree_node) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pt curr;
	mk_sl_tree_wavl_inl_defd_node_pt parent mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t done mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t curr_b mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t parent_b mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt sibling mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t sibling_b mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree_wavl);
	mk_lang_assert(tree_node);

	curr = tree_node;
	parent = curr->m_parent;
	done = mk_lang_false;
	do
	{
		err = mk_sl_tree_wavl_inl_defd_prrw_node_promote_single(parent); mk_lang_check_rereturn(err);
		curr = parent;
		parent = curr->m_parent;
		if(!parent)
		{
			done = mk_lang_true;
			break;
		}
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(curr, &curr_b); mk_lang_check_rereturn(err);
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(parent, &parent_b); mk_lang_check_rereturn(err);
		err = mk_sl_tree_wavl_inl_defd_prrw_node_get_sibling(curr, &sibling); mk_lang_check_rereturn(err);
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(sibling, &sibling_b); mk_lang_check_rereturn(err);
	}while((!curr_b && !parent_b && sibling_b) || (curr_b && parent_b && !sibling_b));
	if(!done)
	{
		if((curr_b && parent_b && sibling_b) || (!curr_b && !parent_b && !sibling_b))
		{
			mk_lang_assert(parent->m_left == curr || parent->m_right == curr);
			if(parent->m_left == curr)
			{
				sibling = curr->m_right;
				if(sibling)
				{
					err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(sibling, &sibling_b); mk_lang_check_rereturn(err);
				}
				if(!sibling || sibling_b == curr_b)
				{
					err = mk_sl_tree_wavl_inl_defd_prrw_rotate_right_single(tree_wavl, curr); mk_lang_check_rereturn(err);
					if(parent)
					{
						err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(parent); mk_lang_check_rereturn(err);
					}
				}
				else
				{
					err = mk_sl_tree_wavl_inl_defd_prrw_rotate_right_double(tree_wavl, sibling); mk_lang_check_rereturn(err);
					err = mk_sl_tree_wavl_inl_defd_prrw_node_promote_single(sibling); mk_lang_check_rereturn(err);
					err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(curr); mk_lang_check_rereturn(err);
					if(parent)
					{
						err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(parent); mk_lang_check_rereturn(err);
					}
				}
			}
			else
			{
				sibling = curr->m_left;
				if(sibling)
				{
					err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(sibling, &sibling_b); mk_lang_check_rereturn(err);
				}
				if(!sibling || sibling_b == curr_b)
				{
					err = mk_sl_tree_wavl_inl_defd_prrw_rotate_left_single(tree_wavl, curr); mk_lang_check_rereturn(err);
					if(parent)
					{
						err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(parent); mk_lang_check_rereturn(err);
					}
				}
				else
				{
					err = mk_sl_tree_wavl_inl_defd_prrw_rotate_left_double(tree_wavl, sibling); mk_lang_check_rereturn(err);
					err = mk_sl_tree_wavl_inl_defd_prrw_node_promote_single(sibling); mk_lang_check_rereturn(err);
					err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(curr); mk_lang_check_rereturn(err);
					if(parent)
					{
						err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(parent); mk_lang_check_rereturn(err);
					}
				}
			}
		}
	}
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_swap_in(mk_sl_tree_wavl_inl_defd_pt const tree, mk_sl_tree_wavl_inl_defd_node_pt const old, mk_sl_tree_wavl_inl_defd_node_pt const neu) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pt left mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt right mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt parent mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt x mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t b mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree);
	mk_lang_assert(old);
	mk_lang_assert(neu);

	left = old->m_left;
	right = old->m_right;
	parent = old->m_parent;
	neu->m_parent = parent;
	if(parent)
	{
		if(parent->m_left == old)
		{
			parent->m_left = neu;
		}
		else
		{
			parent->m_right = neu;
		}
	}
	else
	{
		tree->m_root = neu;
	}
	neu->m_right = right;
	if(neu->m_right)
	{
		x = neu->m_right;
		x->m_parent = neu;
	}
	//old->m_right = mk_lang_null;
	neu->m_left = left;
	if(neu->m_left)
	{
		x = neu->m_left;
		x->m_parent = neu;
	}
	//old->m_left = mk_lang_null;
	err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(old, &b); mk_lang_check_rereturn(err);
	err = mk_sl_tree_wavl_inl_defd_prrw_node_set_rank_bit(neu, b); mk_lang_check_rereturn(err);
	//old->m_parent = mk_lang_null;
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_rebalance_delete_3child(mk_sl_tree_wavl_inl_defd_pt const tree, mk_sl_tree_wavl_inl_defd_node_pt const n, mk_sl_tree_wavl_inl_defd_node_pt const pn) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pt x mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt px mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt y mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt z mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt w mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt v mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt ppx mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t creates_3node mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t done mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t ba mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t bb mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t bc mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree);
	//mk_lang_assert(n); /* todo? */
	mk_lang_assert(pn);

	creates_3node = mk_lang_false;
	done = mk_lang_true;
	x = n;
	px = pn;
	do
	{
		ppx = px->m_parent;
		y = px->m_left == x ? px->m_right : px->m_left;
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(px, &ba); mk_lang_check_rereturn(err);
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(ppx, &bb); mk_lang_check_rereturn(err);
		creates_3node = ppx && ba == bb;
		err = mk_sl_tree_wavl_inl_defd_prro_node_is_2child(y, px, &ba); mk_lang_check_rereturn(err);
		if(ba)
		{
			err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(px); mk_lang_check_rereturn(err);
		}
		else
		{
			err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(y, &ba); mk_lang_check_rereturn(err);
			err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(y->m_left, &bb); mk_lang_check_rereturn(err);
			err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(y->m_right, &bc); mk_lang_check_rereturn(err);
			if(ba == bb && ba == bc)
			{
				err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(px); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(y); mk_lang_check_rereturn(err);
			}
			else
			{
				done = mk_lang_false;
				break;
			}
		}
		x = px;
		px = ppx;
	}while(px && creates_3node);
	if(!done)
	{
		z = px;
		if(px->m_left == x)
		{
			w = y->m_right;
			err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(w, &ba); mk_lang_check_rereturn(err);
			err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(y, &bb); mk_lang_check_rereturn(err);
			if(ba != bb)
			{
				err = mk_sl_tree_wavl_inl_defd_prrw_rotate_left_single(tree, y); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_promote_single(y); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(z); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prro_node_is_leaf(z, &ba); mk_lang_check_rereturn(err);
				if(ba)
				{
					err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(z); mk_lang_check_rereturn(err);
				}
			}
			else
			{
				v = y->m_left;
				err = mk_sl_tree_wavl_inl_defd_prrw_rotate_left_double(tree, v); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_promote_double(v); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(y); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_double(z); mk_lang_check_rereturn(err);
			}
		}
		else
		{
			w = y->m_left;
			err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(w, &ba); mk_lang_check_rereturn(err);
			err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(y, &bb); mk_lang_check_rereturn(err);
			if(ba != bb)
			{
				err = mk_sl_tree_wavl_inl_defd_prrw_rotate_right_single(tree, y); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_promote_single(y); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(z); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prro_node_is_leaf(z, &ba); mk_lang_check_rereturn(err);
				if(ba)
				{
					err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(z); mk_lang_check_rereturn(err);
				}
			}
			else
			{
				v = y->m_right;
				err = mk_sl_tree_wavl_inl_defd_prrw_rotate_right_double(tree, v); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_promote_double(v); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(y); mk_lang_check_rereturn(err);
				err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_double(z); mk_lang_check_rereturn(err);
			}
		}
	}
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr static mk_lang_inline mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_prrw_rebalance_delete_22leaf(mk_sl_tree_wavl_inl_defd_pt const tree, mk_sl_tree_wavl_inl_defd_node_pt const node) mk_lang_noexcept
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t ba mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t bb mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree);
	mk_lang_assert(node);

	if(!(tree->m_root && !tree->m_root->m_left && !tree->m_root->m_right))
	{
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(node, &ba); mk_lang_check_rereturn(err);
		err = mk_sl_tree_wavl_inl_defd_prro_node_get_rank_bit(node->m_parent, &bb); mk_lang_check_rereturn(err);
		err = mk_sl_tree_wavl_inl_defd_prrw_node_demote_single(node); mk_lang_check_rereturn(err);
		if(ba == bb)
		{
			err = mk_sl_tree_wavl_inl_defd_prrw_rebalance_delete_3child(tree, node, node->m_parent); mk_lang_check_rereturn(err);
		}
	}
	return 0;
}


mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr mk_lang_jumbo mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_rw_construct(mk_sl_tree_wavl_inl_defd_pt const tree) mk_lang_noexcept
{
	mk_lang_assert(tree);

	tree->m_root = mk_lang_null;
	tree->m_cnt = 0;
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr mk_lang_jumbo mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_rw_destroy(mk_sl_tree_wavl_inl_defd_pt const tree) mk_lang_noexcept
{
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree);

	err = mk_sl_tree_wavl_inl_defd_prrw_node_destroy_recursive(tree->m_root); mk_lang_check_rereturn(err);
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr mk_lang_jumbo mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_rw_insert(mk_sl_tree_wavl_inl_defd_pt const tree, mk_sl_tree_wavl_inl_defd_element_pct const element, mk_sl_tree_wavl_inl_defd_node_ppct const node) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pt curr mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt tmp mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t cmp mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t leaf mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree);
	mk_lang_assert(element);
	mk_lang_assert(node);

	curr = tree->m_root;
	if(!curr)
	{
		err = mk_sl_tree_wavl_inl_defd_prrw_node_alloc(&curr, mk_lang_null, element); mk_lang_check_rereturn(err); mk_lang_assert(curr);
		++tree->m_cnt;
		tree->m_root = curr;
		*node = curr;
	}
	else
	{
		leaf = mk_lang_false;
		mk_lang_clobber(&tmp);
		do
		{
			err = mk_sl_tree_wavl_inl_defd_elements_compare_fn(element, &curr->m_element, &cmp); mk_lang_check_rereturn(err);
			if(cmp < 0)
			{
				if(curr->m_left)
				{
					curr = curr->m_left;
				}
				else
				{
					leaf = !curr->m_right;
					tmp = curr->m_left;
					err = mk_sl_tree_wavl_inl_defd_prrw_node_alloc(&tmp, curr, element); mk_lang_check_rereturn(err); mk_lang_assert(tmp);
					++tree->m_cnt;
					curr->m_left = tmp;
					*node = tmp;
					break;
				}
			}
			else if(cmp > 0)
			{
				if(curr->m_right)
				{
					curr = curr->m_right;
				}
				else
				{
					leaf = !curr->m_left;
					tmp = curr->m_right;
					err = mk_sl_tree_wavl_inl_defd_prrw_node_alloc(&tmp, curr, element); mk_lang_check_rereturn(err); mk_lang_assert(tmp);
					++tree->m_cnt;
					curr->m_right = tmp;
					*node = tmp;
					break;
				}
			}
			else
			{
				err = mk_sl_tree_wavl_inl_defd_prrw_node_inc(curr); mk_lang_check_rereturn(err);
				*node = curr;
				break;
			}
		}while(curr);
		if(leaf)
		{
			err = mk_sl_tree_wavl_inl_defd_prrw_rebalance_insert(tree, tmp); mk_lang_check_rereturn(err);
		}
	}
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr mk_lang_jumbo mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_rw_find(mk_sl_tree_wavl_inl_defd_pt const tree, mk_sl_tree_wavl_inl_defd_element_pct const element, mk_sl_tree_wavl_inl_defd_node_ppct const node) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pct curr mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t cmp mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree);
	mk_lang_assert(element);
	mk_lang_assert(node);

	curr = tree->m_root;
	while(curr)
	{
		err = mk_sl_tree_wavl_inl_defd_elements_compare_fn(element, &curr->m_element, &cmp); mk_lang_check_rereturn(err);
		if(cmp < 0)
		{
			curr = curr->m_left;
		}
		else if(cmp > 0)
		{
			curr = curr->m_right;
		}
		else
		{
			break;
		}
	}
	*node = curr;
	return 0;
}

mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr mk_lang_jumbo mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_rw_remove(mk_sl_tree_wavl_inl_defd_pt const tree, mk_sl_tree_wavl_inl_defd_node_pct const node) mk_lang_noexcept
{
	mk_sl_tree_wavl_inl_defd_node_pt nd mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t del mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_bool_t is_2child mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt y mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt x mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_sl_tree_wavl_inl_defd_node_pt p_y mk_sl_tree_wavl_inl_defd_constexpr_init;
	mk_lang_types_sint_t err mk_sl_tree_wavl_inl_defd_constexpr_init;

	mk_lang_assert(tree);
	mk_lang_assert(node);

	nd = ((mk_sl_tree_wavl_inl_defd_node_pt)(node));
	err = mk_sl_tree_wavl_inl_defd_prrw_node_dec(nd, &del); mk_lang_check_rereturn(err);
	if(del)
	{
		is_2child = mk_lang_false;
		if(!nd->m_left || !nd->m_right)
		{
			y = nd;
		}
		else
		{
			err = mk_sl_tree_wavl_inl_defd_prrw_node_find_minimum(nd->m_right, &y); mk_lang_check_rereturn(err);
		}
		if(y->m_left)
		{
			x = y->m_left;
		}
		else
		{
			x = y->m_right;
		}
		if(x)
		{
			x->m_parent = y->m_parent;
		}
		p_y = y->m_parent;
		if(!p_y)
		{
			tree->m_root = x;
		}
		else
		{
			err = mk_sl_tree_wavl_inl_defd_prro_node_is_2child(y, p_y, &is_2child); mk_lang_check_rereturn(err);
			mk_lang_assert(p_y->m_left == y || p_y->m_right == y);
			if(p_y->m_left == y)
			{
				p_y->m_left = x;
			}
			else
			{
				p_y->m_right = x;
			}
		}
		if(y != nd)
		{
			err = mk_sl_tree_wavl_inl_defd_prrw_swap_in(tree, nd, y); mk_lang_check_rereturn(err);
			if(p_y == nd)
			{
				p_y = y;
			}
		}
		if(p_y)
		{
			if(is_2child)
			{
				err = mk_sl_tree_wavl_inl_defd_prrw_rebalance_delete_3child(tree, x, p_y); mk_lang_check_rereturn(err);
			}
			else if(!x && p_y->m_left == p_y->m_right)
			{
				err = mk_sl_tree_wavl_inl_defd_prrw_rebalance_delete_22leaf(tree, p_y); mk_lang_check_rereturn(err);
			}
		}
		err = mk_sl_tree_wavl_inl_defd_prrw_node_destroy_single(nd); mk_lang_check_rereturn(err);
		--tree->m_cnt;
	}
	return 0;
}


mk_lang_nodiscard mk_sl_tree_wavl_inl_defd_constexpr mk_lang_jumbo mk_lang_types_sint_t mk_sl_tree_wavl_inl_defd_ro_node_get_element(mk_sl_tree_wavl_inl_defd_node_pct const node, mk_sl_tree_wavl_inl_defd_element_ppct const element) mk_lang_noexcept
{
	mk_lang_assert(node);
	mk_lang_assert(element);

	*element = &node->m_element;
	return 0;
}


#include "mk_sl_tree_wavl_inl_defu.h"


#undef mk_sl_tree_wavl_t_name
#undef mk_sl_tree_wavl_t_element_type
#undef mk_sl_tree_wavl_t_elements_compare
#undef mk_sl_tree_wavl_t_mallocatorg_name
#undef mk_sl_tree_wavl_t_constexpr_want
